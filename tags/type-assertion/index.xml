<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>type assertion on Peter Stace</title>
    <link>http://peterstace.io/tags/type-assertion/</link>
    <description>Recent content in type assertion on Peter Stace</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Wed, 11 Jan 2017 21:14:51 +1100</lastBuildDate>
    
	<atom:link href="http://peterstace.io/tags/type-assertion/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Panic and Recover as Error Handling Mechanisms in Go</title>
      <link>http://peterstace.io/post/2017-01-11-panic-and-recover-as-error-handling-mechanisms/</link>
      <pubDate>Wed, 11 Jan 2017 21:14:51 +1100</pubDate>
      
      <guid>http://peterstace.io/post/2017-01-11-panic-and-recover-as-error-handling-mechanisms/</guid>
      <description>In Go, the generally accepted idiomatic way to handle error conditions is via the builtin error type. In most situations, this leads to clear and easy to understand error handling code.
This isn&amp;rsquo;t always the case though. When dealing with a large number of type assertions, panic and recover can lead to elegant and easy to understand code.
I recently came across this sort of situation while writing a decoder for .</description>
    </item>
    
  </channel>
</rss>