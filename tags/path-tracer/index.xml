<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>path tracer on Peter Stace</title>
    <link>https://petsta.net/tags/path-tracer/</link>
    <description>Recent content in path tracer on Peter Stace</description>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Wed, 26 Jul 2017 13:52:57 +1000</lastBuildDate><atom:link href="https://petsta.net/tags/path-tracer/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Path Tracing Part 4 - Reflections</title>
      <link>https://petsta.net/posts/path-tracing-part-04-reflections/</link>
      <pubDate>Wed, 26 Jul 2017 13:52:57 +1000</pubDate>
      
      <guid>https://petsta.net/posts/path-tracing-part-04-reflections/</guid>
      <description>The mathematics behind specular reflection in path tracing (or ray tracing) is simple.
When a ray encounters a reflective surface, the ray has to be recast following the rule &amp;ldquo;the angle of incidence is equal to the angle of reflection&amp;rdquo;.
Where d_r is the (unit) reflection ray direction, d_i is the (unit) incident ray direction, and n is the unit normal:
d_r = d_i - 2 * n . d_i I recently added specular reflections to my path tracer, Grayt.</description>
    </item>
    
    <item>
      <title>Path Tracing Part 3 - Acceleration Structure</title>
      <link>https://petsta.net/posts/path-tracing-part-03-acceleration-structure/</link>
      <pubDate>Wed, 04 Jan 2017 09:21:37 +1100</pubDate>
      
      <guid>https://petsta.net/posts/path-tracing-part-03-acceleration-structure/</guid>
      <description>I recently added an acceleration data structure to my path tracer. This resulted in a large performance improvement.
The acceleration structure improves the speed of the global ray intersection test, an integral part of any path tracer.
The source code can be found here.
Global Ray Intersection Test The global ray intersection test is the most computationally expensive part of a path tracer. The test takes a ray, and checks to see if it intersects with any of the objects in the scene.</description>
    </item>
    
    <item>
      <title>Path Tracing Part 2 - Depth of Field</title>
      <link>https://petsta.net/posts/path-tracing-part-02-depth-of-field/</link>
      <pubDate>Wed, 21 Dec 2016 19:03:38 +1100</pubDate>
      
      <guid>https://petsta.net/posts/path-tracing-part-02-depth-of-field/</guid>
      <description>Real world cameras can only focus on objects that are a set distance away from them. This distance is known as the subject distance. Objects at other distances will appear more or less out of focus, depending on how far away they are from this point. Objects closer to the camera than the subject distance will appear out of focus, as will objects beyond the subject distance. Objects closer to the subject distance (but still not precisely at it) will still be out of focus, but to a much lesser degree.</description>
    </item>
    
    <item>
      <title>Path Tracing Part 1 - Initial Renders</title>
      <link>https://petsta.net/posts/path-tracing-part-01-initial-renders/</link>
      <pubDate>Tue, 20 Dec 2016 19:55:41 +1100</pubDate>
      
      <guid>https://petsta.net/posts/path-tracing-part-01-initial-renders/</guid>
      <description>Enter Grayt Grayt (Go Ray Tracer) was a project that I started in mid 2014 to help me learn Go. As the name suggests, it started out as a ray tracer. Having implemented ray tracers before (in C++), this was quite straight forward but ultimately wasn&amp;rsquo;t very satisfying. I still wanted a side project to learn Go with, so I pivoted it from a ray tracer to a path tracer. Path tracers are much harder to implement, and produce more realistic renderings.</description>
    </item>
    
  </channel>
</rss>
