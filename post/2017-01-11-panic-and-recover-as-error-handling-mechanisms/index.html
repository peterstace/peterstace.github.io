<!DOCTYPE>
<html>
  <head>
    <title>Panic and Recover as Error Handling Mechanisms in Go</title>
    <link rel="stylesheet" href="/css/main.css"/>
  </head>
  <body>
    <div style="width:35rem;margin:auto;">
      <a href="/"><h1 class="title" style="text-align:center">Peter Stace</h1></a>
      <div style="text-align:center;">
        <a href="https://github.com/peterstace">github</a>
        |
        <a href="https://twitter.com/peterjohnstace">twitter</a>
        |
        <a href="/about">about</a>
      </div>
      <div style="text-align:center;">
        <h2>&middot; &middot; &middot;</h2>
      </div>
      
  <h1>Panic and Recover as Error Handling Mechanisms in Go</h1>
  
    <h3>2017-01-11</h3>
  
  <p>
    
      tags:
      
        
        go
      
        
        golang
      
        
        idiomatic
      
        
        error
      
        
        type assertion
      
        
        torrent
      
        
        decoder
      
    
  </p>
  <p>

<p>In Go, the generally accepted idiomatic way to handle error conditions is via
the builtin <code>error</code> type. In most situations, this leads to clear and easy to
understand error handling code.</p>

<p>This isn&rsquo;t always the case though. When dealing with a large number of type
assertions, panic and recover can lead to elegant and easy to understand code.</p>

<p>I recently came across this sort of situation while writing a decoder for
<code>.torrent</code> files.</p>

<p>This blog post will go through a simplified version of the problem, exhibiting
how and why panic and recover allow better code to be crafted in this
particular situation.</p>

<h2 id="the-problem">The Problem</h2>

<p>A <code>.torrent</code> file consists of an encoded <code>Value</code>. In general, a <code>Value</code> can
either be an <code>int</code>, a <code>string</code>, or a <code>map[string]Value</code>:</p>

<pre><code>// Value is either `int`, `string`, or `map[string]Value`.
type Value interface{}
</code></pre>

<p>However, <code>Value</code>s that are encoded inside <code>.torrent</code> files will contain very
specific structures (the <code>.torrent</code> structure given here is a simplified
version of reality. For the full details of real <code>.torrent</code> files, the spec can
be found <a href="http://bittorrent.org/beps/bep_0003.html">here</a>).</p>

<p>The top level <code>Value</code> in a <code>.torrent</code> file is a <code>map[string]Value</code>. It has two
keys, <code>&quot;announce&quot;</code> and <code>&quot;info&quot;</code>. The <code>&quot;announce&quot;</code> value is a <code>string</code>, which is
the announce URL of the torrent&rsquo;s tracker. The <code>&quot;info&quot;</code> value is another
<code>map[string]Value</code>. This map also has two keys, <code>&quot;name&quot;</code> and <code>&quot;piece length&quot;</code>.
The <code>&quot;name&quot;</code> value contains a <code>string</code>, which is the suggested name of the
torrent.  The <code>&quot;piece length&quot;</code> value contains an <code>int</code>, which is the number of
bytes in each torrent piece.</p>

<p>The task is to take the top level <code>Value</code>, and extract it into the following
type:</p>

<pre><code>type MetaInfo struct {
    AnnounceURL string
    Name        string
    PieceLength int
}
</code></pre>

<p>Missing keys or incorrect types are errors. Extra keys should be ignored (since
they might be file format extensions).</p>

<h2 id="solution-a-traditional-error-handling">Solution A (traditional error handling)</h2>

<p>The traditional approach is to use checked type assertions, returning an error
if the type assertion fails.</p>

<pre><code>func DecodeMetaInfo(v Value) (MetaInfo, error) {

    var m MetaInfo
    err := errors.New(&quot;invalid meta info&quot;)

    topLevelMap, ok := v.(map[string]Value)
    if !ok {
        return m, err
    }
    if m.AnnounceURL, ok = topLevelMap[&quot;announce&quot;].(string); !ok {
        return m, err
    }
    infoMap, ok := topLevelMap[&quot;info&quot;].(map[string]Value)
    if !ok {
        return m, err
    }
    if m.Name, ok = infoMap[&quot;name&quot;].(string); !ok {
        return m, err
    }
    if m.PieceLength, ok = infoMap[&quot;piece length&quot;].(int); !ok {
        return m, err
    }
    return m, nil
}
</code></pre>

<h2 id="solution-b-panic-and-recover">Solution B (panic and recover)</h2>

<p>An alternate solution is to use <code>recover()</code> to check for any panics, and then
use non-checked type assertions. This automatically takes care of the error
cases if the type assertions fail.</p>

<pre><code>func DecodeMetaInfo(v Value) (m MetaInfo, err error) {

    defer func() {
        if r := recover(); r != nil {
            err = errors.New(&quot;invalid meta info&quot;)
        }
    }()

    topLevelMap := v.(map[string]Value)
    m.AnnounceURL = topLevelMap[&quot;announce&quot;].(string)
    infoMap := topLevelMap[&quot;info&quot;].(map[string]Value)
    m.Name = infoMap[&quot;name&quot;].(string)
    m.PieceLength = infoMap[&quot;piece length&quot;].(int)
    return m, nil
}
</code></pre>

<h2 id="comparison">Comparison</h2>

<p>While the line count between the two solutions isn&rsquo;t dramatically different, I
think the second is much easier to read once familiar with the panic and
recover pattern. The logic isn&rsquo;t cluttered with error handling like it is in
the first solution.</p>

<p>The downside to the second solution is that it&rsquo;s impossible to provide a custom
error value for each error case. For my purposes, this didn&rsquo;t really matter.
The end user of the program isn&rsquo;t going to be able to &lsquo;fix&rsquo; a torrent if it&rsquo;s
not well formed, they just need to know that it cannot be loaded.</p>
</p>

    </div>
    <p>
      Copyright &copy;
      
  2017

      Peter Stace
    </p>
  </body>
</html>
