<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on Peter Stace&#39;s Personal Blog</title>
    <link>http://peterstace.io/post/index.xml</link>
    <description>Recent content in Posts on Peter Stace&#39;s Personal Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Wed, 21 Dec 2016 19:03:38 +1100</lastBuildDate>
    <atom:link href="http://peterstace.io/post/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Path Tracing Part 2 - Depth of Field</title>
      <link>http://peterstace.io/post/2016-12-21-path-tracing-part-02-depth-of-field/</link>
      <pubDate>Wed, 21 Dec 2016 19:03:38 +1100</pubDate>
      
      <guid>http://peterstace.io/post/2016-12-21-path-tracing-part-02-depth-of-field/</guid>
      <description>&lt;p&gt;Real world cameras can only focus on objects that are a set distance away from
them. This distance is known as the &lt;em&gt;subject distance&lt;/em&gt;. Objects at other
distances will appear more or less out of focus, depending on how far away they
are from this point. Objects closer to the camera than the subject distance
will appear out of focus, as will objects beyond the subject distance. Objects
closer to the subject distance (but still not precisely at it) will still be
out of focus, but to a much lesser degree.&lt;/p&gt;

&lt;p&gt;Real world cameras can also control the degree to which parts of the image are
out of focus. Typically this is done by adjusting the &lt;em&gt;focal ratio&lt;/em&gt; of the
camera lens. This is the ratio between the focal length of the lens (distance
from lens to image sensor or film) and the lens&amp;rsquo; aperture diameter. The focal
ratio is also known as the &lt;em&gt;f-stop&lt;/em&gt; or &lt;em&gt;f-number&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Depth of field effects can be simulated in a path tracer by modifying how rays
are cast out of the virtual camera. The rays can be perturbed randomly to
simulate light passing through the camera aperture at different points.&lt;/p&gt;

&lt;p&gt;Depth of field effects have now been implemented in my path tracer,
&lt;a href=&#34;https://github.com/peterstace/grayt&#34;&gt;Grayt&lt;/a&gt;. It generated the 9 images below.
Each image is a rendering of the same scene, but with varying subject distances
and focal ratios.&lt;/p&gt;

&lt;table style=&#34;border:1px solid black;border-collapse:collapse;text-align:center&#34;&gt;
  &lt;tr&gt;
    &lt;td rowspan=&#34;2&#34; style=&#34;border:1px solid black&#34;&gt;Focal Ratio&lt;/td&gt;
    &lt;td colspan=&#34;3&#34; style=&#34;border:1px solid black&#34;&gt;Subject Distance&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;/td&gt;
    &lt;td style=&#34;border:1px solid black&#34;&gt;Close&lt;/td&gt;
    &lt;td style=&#34;border:1px solid black&#34;&gt;Mid&lt;/td&gt;
    &lt;td style=&#34;border:1px solid black&#34;&gt;Far&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td style=&#34;border:1px solid black&#34;&gt;Shallow&lt;/td&gt;
    &lt;td&gt;&lt;img src=&#34;http://peterstace.io/static/images/focus/near_50.jpg&#34; /&gt;&lt;/td&gt;
    &lt;td&gt;&lt;img src=&#34;http://peterstace.io/static/images/focus/mid_50.jpg&#34; /&gt;&lt;/td&gt;
    &lt;td&gt;&lt;img src=&#34;http://peterstace.io/static/images/focus/far_50.jpg&#34; /&gt;&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td style=&#34;border:1px solid black&#34;&gt;Medium&lt;/td&gt;
    &lt;td&gt;&lt;img src=&#34;http://peterstace.io/static/images/focus/near_15.jpg&#34; /&gt;&lt;/td&gt;
    &lt;td&gt;&lt;img src=&#34;http://peterstace.io/static/images/focus/mid_15.jpg&#34; /&gt;&lt;/td&gt;
    &lt;td&gt;&lt;img src=&#34;http://peterstace.io/static/images/focus/far_15.jpg&#34; /&gt;&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td style=&#34;border:1px solid black&#34;&gt;Deep&lt;/td&gt;
    &lt;td&gt;&lt;img src=&#34;http://peterstace.io/static/images/focus/near_5.jpg&#34; /&gt;&lt;/td&gt;
    &lt;td&gt;&lt;img src=&#34;http://peterstace.io/static/images/focus/mid_5.jpg&#34; /&gt;&lt;/td&gt;
    &lt;td&gt;&lt;img src=&#34;http://peterstace.io/static/images/focus/far_5.jpg&#34; /&gt;&lt;/td&gt;
  &lt;/tr&gt;
&lt;/table&gt;
</description>
    </item>
    
    <item>
      <title>Path Tracing Part 1 - Initial Renders</title>
      <link>http://peterstace.io/post/2016-12-20-path-tracing-part-01-initial-renders/</link>
      <pubDate>Tue, 20 Dec 2016 19:55:41 +1100</pubDate>
      
      <guid>http://peterstace.io/post/2016-12-20-path-tracing-part-01-initial-renders/</guid>
      <description>

&lt;h2 id=&#34;enter-grayt&#34;&gt;Enter Grayt&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/peterstace/grayt&#34;&gt;Grayt&lt;/a&gt; (&lt;strong&gt;G&lt;/strong&gt;o &lt;strong&gt;Ray&lt;/strong&gt; &lt;strong&gt;T&lt;/strong&gt;racer) was a
project that I started in mid 2014 to help me learn &lt;a href=&#34;https://golang.org&#34;&gt;Go&lt;/a&gt;.
As the name suggests, it started out as a &lt;a href=&#34;https://en.wikipedia.org/wiki/Ray_tracing_(graphics)&#34;&gt;ray
tracer&lt;/a&gt;. Having
implemented ray tracers before (in C++), this was quite straight forward but
ultimately wasn&amp;rsquo;t very satisfying.  I still wanted a side project to learn Go
with, so I pivoted it from a ray tracer to a &lt;a href=&#34;https://en.wikipedia.org/wiki/Path_tracing&#34;&gt;path
tracer&lt;/a&gt;.  Path tracers are much
harder to implement, and produce more realistic renderings. The name &amp;ldquo;Grayt&amp;rdquo;
stuck, even if it&amp;rsquo;s no longer a truly accurate name.&lt;/p&gt;

&lt;p&gt;At its core, a path tracer takes a mathematical description of a 3D scene and
renders it, producing a 2D image. They&amp;rsquo;re able to render highly photo realistic
images by simulating light related physical phenomena that occur in the real
wold.&lt;/p&gt;

&lt;p&gt;Currently, Grayt only supports diffuse reflections. These types of reflections
are only a tiny subset of the reflections that occur in the real world.
However, they allow a path tracer to render matte objects with relative
accuracy.&lt;/p&gt;

&lt;h2 id=&#34;renders&#34;&gt;Renders&lt;/h2&gt;

&lt;p&gt;I started out with 3 different renderings, each showing off different aspects
of the path tracer.&lt;/p&gt;

&lt;h3 id=&#34;cornell-box&#34;&gt;Cornell Box&lt;/h3&gt;

&lt;p&gt;The first scene I implemented is the classic &lt;a href=&#34;https://en.wikipedia.org/wiki/Cornell_box&#34;&gt;Cornell
Box&lt;/a&gt;, originally created at Cornell
University as a 3D test model. My take on the Cornell Box is slightly different
from the original.&lt;/p&gt;

&lt;p&gt;The rendering contains:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;A red &amp;lsquo;left&amp;rsquo; wall.&lt;/li&gt;
&lt;li&gt;A green &amp;lsquo;right&amp;rsquo; wall.&lt;/li&gt;
&lt;li&gt;A white floor and ceiling.&lt;/li&gt;
&lt;li&gt;A white ceiling light.&lt;/li&gt;
&lt;li&gt;Two white blocks.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;All surfaces are matte. A real wold example of a matte surface would be a
non-glossy and slightly rough painted surface.&lt;/p&gt;

&lt;p&gt;In the rendering, you can observer:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Soft shadows being cast by the blocks onto the floor.&lt;/li&gt;
&lt;li&gt;Green and red light being reflected off the green and red walls onto the
white center blocks.&lt;/li&gt;
&lt;li&gt;Occlusion shadows, most visible in the back top corners of the room.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;In a traditional ray tracer, these three effects must be implemented as special
cases (and it&amp;rsquo;s very hard to do so accurately). In path tracing however, we get
them &amp;lsquo;for free&amp;rsquo; by virtue of having implemented diffuse reflections.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://peterstace.io/static/images/cornell_box.jpg&#34; alt=&#34;Cornell Box&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;split-box&#34;&gt;Split Box&lt;/h3&gt;

&lt;p&gt;My second rendering is of a procedurally generated scene of my own design.  I
started by taking a cube and splitting it into two pieces along a random axis.
I then moved each piece slightly against the other. I repeated this on the
remaining cubes over several dozen iterations. The cube stricture is white, and
is situated underneath a white light. Like the Cornell Box, there are coloured
walls to the left and right (off camera) that reflect coloured light into the
scene.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://peterstace.io/static/images/split_box.jpg&#34; alt=&#34;Split Box&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;sphere-tree&#34;&gt;Sphere Tree&lt;/h3&gt;

&lt;p&gt;My third rendering is also of a procedurally generated scene of my own design.
I created a &amp;lsquo;tree&amp;rsquo; structure out of spheres. I started with a large sphere
centered in the floor, and randomly added two &amp;lsquo;child&amp;rsquo; spheres to its surface. I
then added two more child spheres to each of the original child spheres. This
continued until I had several hundred spheres.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://peterstace.io/static/images/sphere_tree.jpg&#34; alt=&#34;Sphere Tree&#34; /&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Bolt250 Part 1 - The Unboxing</title>
      <link>http://peterstace.io/post/2016-01-06-bolt250-part01-unboxing/</link>
      <pubDate>Wed, 06 Jan 2016 22:17:35 +1100</pubDate>
      
      <guid>http://peterstace.io/post/2016-01-06-bolt250-part01-unboxing/</guid>
      <description>&lt;p&gt;I&amp;rsquo;m building a new miniquad, the Bolt250 from &lt;a href=&#34;http://boltrc.com.au&#34;&gt;BoltRC&lt;/a&gt;.
It&amp;rsquo;s a midpriced 250mm class racing quadcopter.&lt;/p&gt;

&lt;p&gt;I went with the ARF kit rather than just getting the frame.&lt;/p&gt;

&lt;p&gt;The Bolt250 comes with two different hardware versions, standard (30mm
standoffs) and stealth (25mm standoffs). It also comes with the choice of 3mm
or 4mm arm thickness, with clearance for either 5&amp;rdquo; or 6&amp;rdquo; props. I opted for the
stealth hardware with 4mm/5&amp;rdquo; arms.&lt;/p&gt;

&lt;p&gt;The frame pieces include:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Bottom, mid, and top plates.&lt;/li&gt;
&lt;li&gt;4 x arms.&lt;/li&gt;
&lt;li&gt;Plastic LED rear mount.&lt;/li&gt;
&lt;li&gt;Front and rear carbon fibre bumpers.&lt;/li&gt;
&lt;li&gt;Small carbon fibre wall to fit between the camera bay area and the center of
the frame.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Also included were:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;D-SUN 3A switching voltage regulator.&lt;/li&gt;
&lt;li&gt;Naze32.&lt;/li&gt;
&lt;li&gt;Mini power distribution board.&lt;/li&gt;
&lt;li&gt;Header pins for the Naze32.&lt;/li&gt;
&lt;li&gt;HS1177 FPV Camera.&lt;/li&gt;
&lt;li&gt;USB ESC programming link.&lt;/li&gt;
&lt;li&gt;4 x ZTW Spider Mini 18A OPTO ESCs.&lt;/li&gt;
&lt;li&gt;4 x Cobra 2204 2300KV motors.&lt;/li&gt;
&lt;li&gt;50mm right-angle VTX pigtail.&lt;/li&gt;
&lt;li&gt;2 x XT-60 male connectors.&lt;/li&gt;
&lt;li&gt;14 and 20 AWG silicone wire.&lt;/li&gt;
&lt;li&gt;Plenty of heatshrink.&lt;/li&gt;
&lt;li&gt;BoltRC battery strap.&lt;/li&gt;
&lt;li&gt;Plenty of zip ties.&lt;/li&gt;
&lt;li&gt;M3 double sided tape.&lt;/li&gt;
&lt;li&gt;8 x Gemfan 5030 props.&lt;/li&gt;
&lt;li&gt;5.8GHz LHCP 3-lobe antenna.&lt;/li&gt;
&lt;li&gt;Fibre washers.&lt;/li&gt;
&lt;li&gt;25mm standoffs.&lt;/li&gt;
&lt;li&gt;Lots of nuts and bolts.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The only problem that I can see so far is that the mounting bolts included with
the motors are suited for 3mm arms instead of 4mm arms. They only engage one or
two threads, and need to be about 1mm longer. Not a problem though, I picked up
some different bolts from Jaycar.&lt;/p&gt;

&lt;p&gt;I&amp;rsquo;m looking forward to building this thing!&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Irregular JSON decoding in Go</title>
      <link>http://peterstace.io/post/2015-06-18-irregular-json-decoding-in-go/</link>
      <pubDate>Thu, 18 Jun 2015 22:03:45 +1100</pubDate>
      
      <guid>http://peterstace.io/post/2015-06-18-irregular-json-decoding-in-go/</guid>
      <description>&lt;p&gt;The Go standard library has an awesome &lt;a href=&#34;http://golang.org/pkg/encoding/json/&#34;&gt;JSON encoding and decoding
package&lt;/a&gt;, which makes handling JSON a
breeze. If you&amp;rsquo;re not familiar with the package, there are plenty of
&lt;a href=&#34;http://blog.golang.org/json-and-go&#34;&gt;web&lt;/a&gt; &lt;a href=&#34;https://gobyexample.com/json&#34;&gt;pages&lt;/a&gt;
&lt;a href=&#34;https://eager.io/blog/go-and-json/&#34;&gt;around&lt;/a&gt; that explain its basic usage.&lt;/p&gt;

&lt;p&gt;Basically, if you know the structure of the JSON value you&amp;rsquo;re encoding, you
create the zero value of the corresponding Go type, and pass a pointer to it
into the &lt;code&gt;json.Unmarshal&lt;/code&gt; (along with the JSON value). Magic occurs, and your
Go object is now populated. If you don&amp;rsquo;t know the structure of your JSON value
upfront, you can instead pass in a &lt;code&gt;map[string]interface{}&lt;/code&gt;, and that will be
populated instead. Type assertions can then be used on the empty interfaces to
determine what actually got decoded.&lt;/p&gt;

&lt;p&gt;But what if you know the precise structure of the JSON, but it&amp;rsquo;s not &lt;em&gt;regular&lt;/em&gt;?
For example, the following JSON value represents a ray tracer scene. The array
&lt;code&gt;&amp;quot;Objects&amp;quot;&lt;/code&gt; contains a known structure, but each element isn&amp;rsquo;t of the same
type. Objects of type &lt;code&gt;&amp;quot;box&amp;quot;&lt;/code&gt; will always have &lt;code&gt;&amp;quot;Corner1&amp;quot;&lt;/code&gt; and &lt;code&gt;&amp;quot;Corner2&amp;quot;&lt;/code&gt;
fields, and objects of type &lt;code&gt;&amp;quot;sphere&amp;quot;&lt;/code&gt; will always have &lt;code&gt;&amp;quot;Centre&amp;quot;&lt;/code&gt; and
&lt;code&gt;&amp;quot;Radius&amp;quot;&lt;/code&gt; fields.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{
    &amp;quot;Colour&amp;quot;: &amp;quot;white&amp;quot;,
    &amp;quot;Material&amp;quot;: &amp;quot;lambertian&amp;quot;,
    &amp;quot;Objects&amp;quot;: [
        {
            &amp;quot;Type&amp;quot;: &amp;quot;box&amp;quot;,
            &amp;quot;Corner1&amp;quot;: {&amp;quot;X&amp;quot;:0,&amp;quot;Y&amp;quot;:1,&amp;quot;Z&amp;quot;:2},
            &amp;quot;Corner2&amp;quot;: {&amp;quot;X&amp;quot;:5,&amp;quot;Y&amp;quot;:6,&amp;quot;Z&amp;quot;:7}
        },
        {
            &amp;quot;Type&amp;quot;: &amp;quot;sphere&amp;quot;,
            &amp;quot;Centre&amp;quot;: {&amp;quot;X&amp;quot;:2,&amp;quot;Y&amp;quot;:2.5,&amp;quot;Z&amp;quot;:-1},
            &amp;quot;Radius&amp;quot;: 1.0
        }
    ]
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I want to decode the JSON value into the follow Go data structure:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;type World struct {
    Colour   string
    Material string
    Objects  []Object
}

type Object interface {
    Contains(Vect) bool
}

type Box struct {
    Corner1, Corner2 Vect
}
func (b Box) Contains(Vect) bool { ... }

type Sphere struct {
    Centre Vect
    Radius float64
}
func (s Sphere) Contains(Vect) bool { ... }

type Vect struct {
    X, Y, Z float64
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Go can&amp;rsquo;t unmarshal the JSON value into &lt;code&gt;World&lt;/code&gt; directly. The &lt;code&gt;json.Unmarshal&lt;/code&gt;
function will return an error &amp;ldquo;json: cannot unmarshal object into Go value of
type main.Object&amp;rdquo;. This makes sense, since the JSON value and the &lt;code&gt;World&lt;/code&gt; Go
type both have fields named &lt;code&gt;Objects&lt;/code&gt;, but &lt;code&gt;Object&lt;/code&gt; is a Go interface, so
cannot be unmarshalled into.&lt;/p&gt;

&lt;p&gt;We need to perform custom unmarshalling into the &lt;code&gt;World&lt;/code&gt; type by implementing
the &lt;a href=&#34;http://golang.org/pkg/encoding/json/#Unmarshaler&#34;&gt;Unmarshaler&lt;/a&gt; interface.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func (w *World) UnmarshalJSON(p []byte) error {

    // Unmarshal the regular parts of the JSON value.
    record := struct {
        Colour   string
        Material string
        Objects  []json.RawMessage
    }{}
    if err := json.Unmarshal(p, &amp;amp;record); err != nil {
        return err
    }
    w.Colour = record.Colour
    w.Material = record.Material

    // Go back to the irregular parts, find each type and unmarshal accordingly.
    for _, rawObject := range record.Objects {

        // Find the type.
        obj := struct{ Type string }{}
        if err := json.Unmarshal(rawObject, &amp;amp;obj); err != nil {
            return err
        }

        // Perform type specific unmarshalling.
        switch obj.Type {
        case &amp;quot;box&amp;quot;:
            var b Box
            if err := json.Unmarshal(rawObject, &amp;amp;b); err != nil {
                return err
            }
            w.Objects = append(w.Objects, b)
        case &amp;quot;sphere&amp;quot;:
            var s Sphere
            if err := json.Unmarshal(rawObject, &amp;amp;s); err != nil {
                return err
            }
            w.Objects = append(w.Objects, s)
        }
    }
    return nil
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So what&amp;rsquo;s happening here? We are essentially doing the following:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Create a variable called &lt;code&gt;record&lt;/code&gt; that allows us to decode the regular parts
(&lt;code&gt;Colour&lt;/code&gt; and &lt;code&gt;Material&lt;/code&gt;). It also decodes the &lt;em&gt;irregular&lt;/em&gt; parts into
&lt;code&gt;json.RawMessage&lt;/code&gt; objects.&lt;/li&gt;
&lt;li&gt;Iterate over each &lt;code&gt;json.RawMessage&lt;/code&gt;, and extract enough information to work
out which type we should unmarshal into. In this case, it&amp;rsquo;s easy, we just
look for the  &lt;code&gt;&amp;quot;Type&amp;quot;&lt;/code&gt; field, and switch based on that.&lt;/li&gt;
&lt;li&gt;Decode into the appropriate type as determined in step 2.&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>Go, gofmt, and diffs</title>
      <link>http://peterstace.io/post/2015-06-02-go-gofmt-and-diff/</link>
      <pubDate>Tue, 02 Jun 2015 22:00:15 +1100</pubDate>
      
      <guid>http://peterstace.io/post/2015-06-02-go-gofmt-and-diff/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://golang.org/cmd/gofmt/&#34;&gt;Gofmt&lt;/a&gt; is a Go program formatter. Its universal
adoption by the Go community has resulted in a consistent formatting style
among most if not all Go source code.&lt;/p&gt;

&lt;p&gt;When making changes to Go code, gofmt sometimes causes changes to lines of code
that weren&amp;rsquo;t originally modified. This can done for example to keep indentation
consistent. This can make diffs hard to read.&lt;/p&gt;

&lt;p&gt;For example, the following is a diff of a simple
&lt;a href=&#34;https://golang.org/ref/spec#Type_declarations&#34;&gt;type declaration&lt;/a&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git diff
diff --git a/main.go b/main.go
index 2c7af41..d9e59cd 100644
--- a/main.go
+++ b/main.go
@@ -1,13 +1,12 @@
 type foo struct {
-    jabberwocky  int
-    quux         complex128
-    galumphing   string
-    vorpal       float64
-    bandersnatch float64
-    mimsy        struct {
-        beaming  int
-        tumtummy string
-        brillig  float64
+    jabberwocky int
+    quux        complex64
+    tumtummy    string
+    galumphing  string
+    vorpal      float64
+    mimsy       struct {
+        beaming int
+        brillig float64
     }
 }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Because gofmt has rewritten the source code to have consistent indentation, at
least a whitespace change has been made to every line. It can be hard to see
what the &lt;em&gt;real&lt;/em&gt; change is.&lt;/p&gt;

&lt;p&gt;To see the real changes, the diff algorithm should be configured to ignore
whitespace. The diff below makes it quite obvious what the actual change is:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git diff -b
diff --git a/main.go b/main.go
index 2c7af41..d9e59cd 100644
--- a/main.go
+++ b/main.go
@@ -1,12 +1,11 @@
 type foo struct {
     jabberwocky int
-    quux         complex128
+    quux        complex64
+    tumtummy    string
     galumphing  string
     vorpal      float64
-    bandersnatch float64
     mimsy       struct {
         beaming int
-        tumtummy string
         brillig float64
     }
 }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It&amp;rsquo;s now quite clear that &lt;code&gt;quux&lt;/code&gt; has had its type modified, &lt;code&gt;bandersnatch&lt;/code&gt; has
been removed, and &lt;code&gt;tumtummy&lt;/code&gt; has been moved from the inner struct, to the outer
struct.&lt;/p&gt;

&lt;p&gt;This type of diff can typically be created by passing the
&lt;code&gt;--ignore-space-change&lt;/code&gt; flag (the short version is &lt;code&gt;-b&lt;/code&gt;). This works with Git,
Mercurial, Subversion, and well as the &lt;code&gt;diff&lt;/code&gt; command that comes with
&lt;code&gt;diffutils&lt;/code&gt;.  GUI based diffs such as those &lt;a href=&#34;https://github.com/blog/967-github-secrets&#34;&gt;produced by
Github&lt;/a&gt; will typically have an
ignore-whitespace option as well.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Where should I put my mocks in Go?</title>
      <link>http://peterstace.io/post/2015-05-21-where-should-i-put-my-mocks-in-go/</link>
      <pubDate>Thu, 21 May 2015 21:51:39 +1100</pubDate>
      
      <guid>http://peterstace.io/post/2015-05-21-where-should-i-put-my-mocks-in-go/</guid>
      <description>

&lt;h2 id=&#34;introduction&#34;&gt;Introduction&lt;/h2&gt;

&lt;p&gt;Go&amp;rsquo;s toolchain provides a mechanism to help prevent test code from being
included in production binaries. It should be obvious why this is useful; if
stubs or mocks intended for testing make their way your production system, they
may cause it to fail silently in catastrophic and unexpected ways. This is
especially a concern if you don&amp;rsquo;t have automated application and integration
tests in place. Imagine if you somehow end up with a stubbed out authentication
manager that always returns &lt;code&gt;true&lt;/code&gt; when asked if a user has administration
privileges. Yikes.&lt;/p&gt;

&lt;p&gt;This blog post will explain this mechanism, along with some of the ways you can
most effectively take advantage it, especially when dealing with mocks and
stubs.&lt;/p&gt;

&lt;h2 id=&#34;the-mechanism&#34;&gt;The Mechanism&lt;/h2&gt;

&lt;p&gt;It&amp;rsquo;s well known that the &lt;code&gt;go test&lt;/code&gt; tool looks in files that end in &lt;code&gt;_test.go&lt;/code&gt;
for tests to run. What is less well known is that these &lt;code&gt;*_test.go&lt;/code&gt; files are
&lt;em&gt;excluded&lt;/em&gt; from binaries built using &lt;code&gt;go build&lt;/code&gt; and &lt;code&gt;go install&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Excellent! This means we can put all of our testing stubs and mocks in the
&lt;code&gt;*_test.go&lt;/code&gt; files and they will never accidentally be included in production
binaries!&lt;/p&gt;

&lt;h2 id=&#34;the-problem&#34;&gt;The Problem&lt;/h2&gt;

&lt;p&gt;This works well most of the time. You have an interface &lt;code&gt;Foo&lt;/code&gt; declared in
package &lt;code&gt;foo&lt;/code&gt;, and a mocked out implementation &lt;code&gt;MockFoo&lt;/code&gt; also in package &lt;code&gt;foo&lt;/code&gt;
but in a file named &lt;code&gt;mock_foo_test.go&lt;/code&gt;. This works great, you can use &lt;code&gt;MockFoo&lt;/code&gt;
instead of the real implementation for all of your tests in package &lt;code&gt;foo&lt;/code&gt;!&lt;/p&gt;

&lt;p&gt;But what if you want to use &lt;code&gt;MockFoo&lt;/code&gt; for tests in packages &lt;code&gt;garply&lt;/code&gt; and
&lt;code&gt;waldo&lt;/code&gt;? Unfortunately you can&amp;rsquo;t. Because &lt;code&gt;MockFoo&lt;/code&gt; is declared in a file
ending in &lt;code&gt;_test.go&lt;/code&gt;, it can only be used in tests contained in the same
package.&lt;/p&gt;

&lt;h2 id=&#34;the-solutions&#34;&gt;The Solutions&lt;/h2&gt;

&lt;p&gt;There are a two obvious ways to work around this:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Rename the file containing &lt;code&gt;MockFoo&lt;/code&gt; from &lt;code&gt;mock_foo_test.go&lt;/code&gt; to
&lt;code&gt;mock_foo.go&lt;/code&gt;. Now that it&amp;rsquo;s not a test file, it can be accessed from other
packages.&lt;/li&gt;
&lt;li&gt;Copy &lt;code&gt;mock_foo_test.go&lt;/code&gt; into the other packages that need it (modifying the
package declaration to match its destination package).&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;There are some drawbacks to both approaches.&lt;/p&gt;

&lt;p&gt;In the first approach, we lose the guarantee that &lt;code&gt;MockFoo&lt;/code&gt; won&amp;rsquo;t accidentally
be included the production binary.  As an additional annoyance, &lt;code&gt;MockFoo&lt;/code&gt; is
now part of the public API, and as such will appear in listings produced by the
&lt;code&gt;godoc&lt;/code&gt; tool.&lt;/p&gt;

&lt;p&gt;The second approach violates the &lt;a href=&#34;http://c2.com/cgi/wiki?DontRepeatYourself&#34;&gt;DRY
principal&lt;/a&gt;. If the interface
changes, you then have to go and change all of the mocks. If you&amp;rsquo;re manually
rolling your own mocks, the process of updating them all could be error prone.&lt;/p&gt;

&lt;p&gt;In my opinion, the second approach is the better of the two, especially when
considering that mocks can be generated automatically with tools such as
&lt;a href=&#34;https://code.google.com/p/gomock/&#34;&gt;gomock&lt;/a&gt;. If you write a small script that
generates all of the mocks in your project using gomock, then you just have to
run it whenever you change an interface that is being mocked out. Since the
mocks are generated &lt;em&gt;from&lt;/em&gt; the interface, I don&amp;rsquo;t think that the DRY principal
is of great importance here.&lt;/p&gt;

&lt;p&gt;Happy testing!&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>